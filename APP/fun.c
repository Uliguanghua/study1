#include "includes.h"
#include "led.h"
#include "pwm.h"
#include "DMA.h"
 
extern u8 SendBuff[200];//发送缓冲区
extern u8 Rx_Buff[650];//接收缓冲区

struct V{
  //计量数据
  u16 UART1_ReceiveSize; //DMA接收数据的长度
  u16 recv_len; //发送数据实际长度
  u8  recv_times;//接收数据次数
  u8  interruput_times;//计数器中断次数 
  TIM_TypeDef * CNT_TIMx;//计数定时器
  TIM_TypeDef * PWM_TIMx;//PWM定时器

  //参数数据
  u8 sd;//当前数据段数
  u16 pulse_remainder;//脉冲余数
  u8 pulse_offset[20];//每一段的起始位（偏移量）
  u32 pulse_num;//总脉冲段数，默认两段脉冲
  u32 output_port;//输出端子，默认为0
  u16 mode;//脉冲段模式
  u32 data[600];//脉冲段数据
  u8 pulse_data[21][31];//脉冲数据指令
  
};

extern struct V Volume;


u32 My_Atoi(char *source) //字符串转整形,遇到第一个非数字停止
{
        
	int length = 0 ; //计算长度
         while(source[length] >= '0' && source[length] <= '9')
          length++;
	u32 temp_sum = 0;
	for(int tmp=0;tmp<length;tmp++) 
          temp_sum = (source[tmp]-'0')+ (temp_sum*10) ; //字符转数字并合并
	return temp_sum;
}

void My_Itoa (u16 num,char str[])//整型转字符串
{
        u8 offset=0;

        do{
            str[offset++]=num%10+'0';//取下一个数字
           }
        while ((num/=10)>0);//删除该数字
        
        u8 str_len = strlen(str)-1;
        u8 start_wei=0;
        
        while(str_len>start_wei)
        {
          str[start_wei]^=str[str_len];
          str[str_len]^=str[start_wei];
          str[start_wei]^=str[str_len];
          str_len--;
          start_wei++;
        }         
}


void Led_Status(u8 state)//LED 状态
{
  switch(state)
  {
  case 0:{STA_LED0=0;
          STA_LED1=1;
          STA_LED2=1;};break;
          
  case 1:{STA_LED0=1;
          STA_LED1=0;
          STA_LED2=1;};break;
          
  case 2:{STA_LED0=1;
          STA_LED1=1;
          STA_LED2=0;};break;
          
  default:{STA_LED0=1;
          STA_LED1=1;
          STA_LED2=1;};break;
  }
}
/*
bool Output_Check(u8 *recv_data)//输出端子有效性检测
{
  u8 data_len=strlen((char *)recv_data);
  if(data_len > 2 || data_len ==0)//长度检查
    return false;
  
    if(recv_data[0]!='Y' || (recv_data[1]<'0' || recv_data[1]>'3'))
      return false;
    
  return true;
}

bool Number_Sum_Check(u8 *recv_data)//总脉冲段数有效性检测
{
  u8 data_len=0;
  while(*recv_data >='0' && *recv_data <= '9')
  {
    data_len++;
    recv_data++;
  }
          
  if(data_len > 2 || data_len == 0)//长度检查
    return false;
  
  u32 data=My_Atoi((char *)recv_data);
  if(data > 20 || data == 0)
    return false;
  return true;
}
*/

bool Speed_Check(u8 *recv_data)//脉冲数率有效性检测
{
  u8 * p = recv_data;
  u8 data_len=strlen((char *)p);
  if(data_len > 6 || data_len == 0)//长度检查
    return false;
  u8 temp;
  for(temp=0;temp<data_len;temp++)
  {
    if(*p> '9' || *p <'0')
      return false;
    p++;
  }
  u32 data=My_Atoi((char *)p);
  if(data > 200000 || data == 0)
    return false;
  return true;
  
}

bool Number_Check(u8 *recv_data)//脉冲个数有效性检测
{
  u8 *p = recv_data;
  u8 temp=0;
  u8 data_len=strlen((char *)p);
  if(data_len>10 || data_len==0)
    return false;
  if(data_len ==10 && *p > '2')
    return false;
  
  for(;temp<data_len;temp++)
  {
    if(*p > '9' || *p < '0')
      return false;
    p++;
  }
  
  
  u32 data=My_Atoi((char *)p);
  if(data > 2147483647 || data == 0)
    return false;
  return true;
  
}

bool Mode_Check(u8 *recv_data)//脉冲模式有效性检测
{
  if('F' == *recv_data || 'T' == *recv_data || 'S' == *recv_data || 'A' == *recv_data || 'E' == *recv_data || 
      'X' == *recv_data )
    if('\0' == *(recv_data+1))
    return true;
  return false; 
}

bool Time_Register_Check(u8 *recv_data)//时间寄存器有效性检测
{
  if(recv_data[0] != 'T')
    return false;
  u8 data_len=strlen((char *)recv_data);
  if(data_len > 4)
    return false;
  recv_data[0]=recv_data[1];
  recv_data[1]=recv_data[2];
  recv_data[2]=recv_data[3];
  recv_data[3]=recv_data[4];
   u32 data=My_Atoi((char *)recv_data);
   if(data > 100 || data == 0)
     return false;
   return true;
  
}

bool Signal_Register_Check(u8 *recv_data)//信号寄存器有效性检测
{
  if(recv_data[0] != 'S')
    return false;
  u8 data_len=strlen((char *)recv_data);
  if(data_len > 4)
    return false;
  recv_data[0]=recv_data[1];
  recv_data[1]=recv_data[2];
  recv_data[2]=recv_data[3];
  recv_data[3]=recv_data[4];
   u32 data=My_Atoi((char *)recv_data);
   if(data > 100 || data == 0)
     return false;
   return true;
  
}

bool External_Signal_Check(u8 *recv_data)//外部信号端子有效性检测
{
  if(recv_data[0] != 'W')
    return false;
  u8 data_len=strlen((char *)recv_data);
  if(data_len > 2)
    return false;
  recv_data[0]=recv_data[1];
  recv_data[1]=recv_data[2];
   u32 data=My_Atoi((char *)recv_data);
   if(data > 4)
     return false;
   return true;
}

bool Time_Check(u8 *recv_data)//时间有效性检测
{
  u8 *p=recv_data;
  
  u8 data_len=strlen((char *)p);
  if(data_len > 5 || data_len==0)//长度检查
    return false;
  u8 temp=0;
  for(;temp<data_len;temp++)
  {
    if(*p > '9' || *p < '0')//数字检查
      return false;
    p++;
  }
  u32 data=My_Atoi((char *)p);
  if(data > 65535|| data == 0)//数值检查
    return false;
  
   return true; 
}

bool Section_Num_Check(u8 *recv_data)//跳转脉冲段序号有效性检测
{
  u8 * p = recv_data;
  u8 data_len=0;
  while(*p < '9' && *p > '0')
  {
    p++;
    data_len++;
  }
    p = recv_data;//重置位置
    
  if(data_len > 2 || data_len == 0)//长度检查
    return false;
  
  u8 temp=0;
  for(;temp<data_len;temp++)
  {
    if(*p > '9' || *p < '0')//数字检查
      return false;
    p++;
  }
  
  u32 data=My_Atoi((char *)p);
  if(data > Volume.pulse_num)//数值检查
    return false;
  
   return true; 
}

 
    if(0 == strcmp((char const *)recv_data,"set_end"))

    return true;
  
   return false; 

}

void Output_Place(u32 data)//端子指定定时器初始化
{

  switch(data)
  {
  case 0:{//Y0输出
            PWM_TIM10_Configuration();
            CNT_TIM9_Configuration(TIM_TS_ITR2); 
            
  }break;
  case 1:{//Y1输出
            PWM_TIM13_Configuration();
            CNT_TIM12_Configuration(TIM_TS_ITR2);
      
  }break;
  case 2:{//Y2输出
            PWM_TIM11_Configuration();
            CNT_TIM9_Configuration(TIM_TS_ITR3);
   
  }break;
  case 3:{//Y3输出
           PWM_TIM14_Configuration();
           CNT_TIM12_Configuration(TIM_TS_ITR3);
        
  }break;
  
  
  }
}

void Frequency_Select(u32 *PWM_CK_CNT,u16 *PWM_PRESCALER,TIM_TypeDef * PWM_TIMx,u32 frequency,u32 port)//根据脉冲频率设置寄存器值
{

   if(port == 0 || port == 2)
   {
      if(frequency > 1000)
     {
          if(frequency > 100000)
          {
              *PWM_CK_CNT =4000000 ;               
              *PWM_PRESCALER = (168000000/4000000 - 1);  //预分频值
               TIM_PrescalerConfig(PWM_TIMx, *PWM_PRESCALER, TIM_PSCReloadMode_Immediate);//立即更新预分频参数
              
           }else
          {
              *PWM_CK_CNT =1000000 ;               
              *PWM_PRESCALER = (168000000/1000000 - 1);  //预分频值
               TIM_PrescalerConfig(PWM_TIMx, *PWM_PRESCALER, TIM_PSCReloadMode_Immediate);//立即更新预分频参数
           }
                 
      }else
      {             
              *PWM_CK_CNT =10000 ;               
              *PWM_PRESCALER = (168000000/10000 - 1);  //预分频值
               TIM_PrescalerConfig(PWM_TIMx, *PWM_PRESCALER, TIM_PSCReloadMode_Immediate);//立即更新预分频参数
      }
      
   }else
   {
      if(frequency > 1000)
     {
          if(frequency > 100000)
          {
              *PWM_CK_CNT =4000000 ;               
              *PWM_PRESCALER = (84000000/4000000 - 1);  //预分频值
               TIM_PrescalerConfig(PWM_TIMx, *PWM_PRESCALER, TIM_PSCReloadMode_Immediate);//立即更新预分频参数
           }else
          {
              *PWM_CK_CNT =1000000 ;               
              *PWM_PRESCALER = (84000000/1000000 - 1);  //预分频值
               TIM_PrescalerConfig(PWM_TIMx, *PWM_PRESCALER, TIM_PSCReloadMode_Immediate);//立即更新预分频参数
           }
                 
      }else
      {             
              *PWM_CK_CNT =10000 ;               
              *PWM_PRESCALER = (84000000/10000 - 1);  //预分频值
               TIM_PrescalerConfig(PWM_TIMx, *PWM_PRESCALER, TIM_PSCReloadMode_Immediate);//立即更新预分频参数
      }
   
   }

}

void Print_Mode_Switch(u8 * send_data)//数据打印
{
  
      strcpy((char *)SendBuff,(const char*)send_data);
      Volume.recv_len = strlen((const char *)SendBuff); 
      MYDMA_Enable(DMA2_Stream7,Volume.recv_len); 
       while(1)
	 {
            if(DMA_GetFlagStatus(DMA2_Stream7,DMA_FLAG_TCIF7)!=RESET)
            { 
              DMA_ClearFlag(DMA2_Stream7,DMA_FLAG_TCIF7);
              break; 
             }
         }
}

bool Data_Head_Check(u8 *p)//数据头
{
  //数据头
  if(Rx_Buff[0] == 'H')
  {
    p++;
    if(Rx_Buff[1] == '-')
    {
      p++;
      if(Rx_Buff[2] == 'Y')
      {
        p++;
        if(Rx_Buff[3] > '0' && Rx_Buff[3] < '4')
        {
          p++;
          if(Rx_Buff[1] == '-')
          {
             p++;
             if(Number_Sum_Check(p))
             {
              p++;
                if(*p == '\r' && *(p+1) == '\n')
                {
                  p+=2;
                  return true;
                }               
                else 
                  return false;
             }else
               return false;
               
          }else
            return false;
           
        }else
          return false;
          
      }else
        return false;
        
    }else
       return false;     
  }          
  else
    return false;

}

u8 Pulse_Data(u8 *p)//数据段错误判断，正确返回0，错误返回非0值
{
  if(!Speed_Check(p))
    return 1;
  
  else
  {
    p=p+strlen((const char *)p)+1;
    if(!Number_Check(p))
    return 1;
    
    else
    {
      p=p+strlen((const char *)p)+1;
      if(!Mode_Check(p))//模式判断
        return 1;
      else
      {
        switch(*p)
        {
          case 'F':{
            p=p+strlen((const char *)p)+1;
            if(!Section_Num_Check(p))
              return 1;
            else 
            {
              while(*p < '9' && *p > '0')
                p++;
              if(*p == '\r' && *(p+1) == '\n')
              {
                p+=2;
                return Pulse_Data(p);//跑下一段
              }
               
            }
             
          };break;
        case 'T':{
            p=p+strlen((const char *)p)+1;
            if(!Time_Check(p))
              return 1;
            
            
          };break;
          case 'S':{
            p=p+strlen((const char *)p)+1;
          };break;
          case 'A':{
            p=p+strlen((const char *)p)+1;
          };break;
          case 'E':{
            p=p+strlen((const char *)p)+1;
          };break;
          case 'X':{
            p=p+strlen((const char *)p)+1;
          };break;
         
        }
        
        
      }
    }
  
  }

  
}

bool Data_Format_Check(u8 *p)//数据格式判断
{
  if(!Data_Head_Check(p))//数据头判断
    return false;
  u16 data_len = strlen((const char *) p);//数据长度
  u16 temp = 0;
  u8 * str=p;
  for(;temp<data_len;temp++)//数据分隔符替换为0
  {
    if(*str == '-')
      *str = 0;
    str++;
  }
  
    
}


u8 Data_Check(void)//数据帧校验,长度错误返回1，格式错误返回2，数据错误返回3，正确返回0
{
  u8 len =strlen((char const*)Rx_Buff);//接收数据长度
  if(len < 15 || len > 607)//长度
    return 1;
  u8 *p=Rx_Buff;
  
 if(!Data_Format_Check())
 return 2;
 
  return 0;
}
